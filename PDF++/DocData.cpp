#include "stdafx.h"
#include "DocData.h"
#include "Document.h"
#include "pdfReader.h"

namespace Pdf{
using namespace Security;

CDocData::CDocData(void)  
{
	m_Parser = nullptr;
//	m_Pages = nullptr;
	m_pSecurity = m_pNewSecurity = nullptr;

	m_bNew = m_bIsLocked = m_bIsReadOnly = m_bDirty = m_bEncrypted = false;
	m_bTemp = true;

	m_fVersion = 1.7F;
	m_sHeaderComments = "%=========================\n% Generated by PDF++ - Copyright (c) 2015 Glen Underwood\n%=========================";

	//OutputStyle = pdfOutputStyle.Default ;

}


CDocData::~CDocData(void)
{
	try{
		Close();
	}
	catch(...){}
}
//
bool CDocData::IsOpen() const {  return m_bNew || m_stm.is_open(); };

void CDocData::Close()
{
	if( m_stm.is_open() )
	{
		try
		{
			m_Parser->Reset(nullptr);
			delete m_Parser;
			m_Parser = nullptr;

			//no need to clean up more than this: just set to a blank dictionary.
			// this may be its last reference and may delete itself
			// this is because we can clean up the real data in the following loop.
			//m_Trailer.SetData( nullptr );
			//if( m_Trailer.GetData() != nullptr ) 
			//	m_Trailer.GetData()->Close();
			m_Trailer = pdfDictionary();
		}
		catch( ... )
		{
		}

		m_stm.close();
	}

	if (m_bTemp && m_filename.length()>0 )
	{
		try
		{
#ifdef __GNUC__
			::remove( m_filename.c_str() );
#else
			::DeleteFileA( m_filename.c_str() );
#endif
		}
		catch(...)
		{
		}
	}

	m_bTemp = true;

	m_filename.clear();

	m_sHeaderComments.clear();

	m_bIsLocked = m_bIsReadOnly = m_bDirty = m_bEncrypted = false;

	m_fVersion = 1.7F;

	try
	{
		if( m_pSecurity != nullptr )
			delete m_pSecurity;
	}
	catch(...)
	{
	}
	/*try
	{
		if( m_pNewSecurity != nullptr )
			delete m_pNewSecurity;
	}
	catch(...)
	{
	}*/
	m_pSecurity = m_pNewSecurity = nullptr;
}

};//namespace Pdf
