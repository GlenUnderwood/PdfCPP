#include "stdafx.h"
#include <stdlib.h>
#include <ctype.h>
#include "Model.h"
#include "Document.h"
#include "SecurityHandler.h"
#include "Writer.h"

//#define IsDigit( c ) (c >= '0' && c <= '9')

using namespace Pdf::Security;

namespace Pdf {

pdfWriter::pdfWriter()
{
	m_iIndent = 3;
	m_iMaxCharsPerLine = 0;
	m_OutputStyle = Default;

	m_secEncryptor = 
	m_secDecryptor = nullptr;
	m_bSuspendEncryption = false;
}

pdfWriter::~pdfWriter()
{
}

int pdfWriter::GetMaxCharsPerLine()
{
	return m_iMaxCharsPerLine;
}

void pdfWriter::SetMaxCharsPerLine( const int i )
{
	if ( i < 0 )
		m_iMaxCharsPerLine = 0;
	else
		m_iMaxCharsPerLine = i;
}

OutputStyle pdfWriter::GetOutputStyle()
{ 
	return m_OutputStyle;
}

void pdfWriter::SetOutputStyle( const OutputStyle i )
{
	m_OutputStyle = i;
}

int pdfWriter::GetIndent()
{ 
	return m_iIndent;
}

void pdfWriter::SetIndent( const int value )
{
	if ( value < 0 )
		m_iIndent = 0;
	else
		m_iIndent = value;
}

void pdfWriter::Write( const pdfDocument& doc, std::ostream& stm )
{
	CDocData& docData( *(const_cast<CDocData*>(doc.GetData())) );
	//if( doc == nullptr)
	//	throw pdfException("pdfWriter requires a valid document object to function.");
	m_secEncryptor = 
	m_secDecryptor = nullptr;
	m_bSuspendEncryption = false;

	Decrypt( doc );

	byte bPDFMarker[5] = { 226, 227, 207, 211, 0 };


	// write out a header
	stm << "%PDF-" <<  docData.m_fVersion << std::endl << '%';
	stm.write( (const char*)bPDFMarker, 4 ) << std::endl;

	if( docData.m_sHeaderComments.length() > 0 )
		stm << docData.m_sHeaderComments << std::endl;
	else
		stm << "% Generated by PDF++" << std::endl;

#ifdef _DEBUG
	stm << "%======= DEBUG ===========" << std::endl 
		<< "% OutputStyle:\t\t" << m_OutputStyle << std::endl 
		<< "% MaxCharsPerLine:\t" << m_iMaxCharsPerLine << std::endl 
		<< "% Indent:\t\t\t" << m_iIndent << std::endl 
		<< "%=========================" << std::endl;
#endif

	//
	pdfDictionary dictTrailer( docData.m_Trailer );

	// we need this to do enc/dec ops.
	pdfObjId idEncrypt;
	if ( dictTrailer.Has( "Encrypt" ) )
		idEncrypt = dictTrailer[ "Encrypt" ].GetId();

	// should we write the new Encrypt?
	pdfDictionary dicSavEnc( docData.m_bEncrypted ? dictTrailer.Get( "Encrypt" ) : pdfDictionary() );
	pdfDictionary dNewEnc;
	if ( docData.m_pNewSecurity != nullptr )
	{
		dNewEnc = docData.m_pNewSecurity->EncryptionDictionary();
		if ( !dNewEnc.IsNull() )
			dictTrailer.Set( "Encrypt", dNewEnc );

	}

	// now all the referenced objs from the ref table
	int lNextID = 1, iSections = 1, iFirstFree = 0;
	std::list<pdfReference> lstSection;
	std::list<std::list<pdfReference>> lstNewTable;
	string buffEndObj = "";
	
	if ( m_OutputStyle == Neat || m_OutputStyle == NicelyFormatted )
		buffEndObj = "\nendobj\n";//buffEndObj = Encoding.ASCII.GetBytes( string.Format( "{0}endobj{1}", std::endl, std::endl ) );
	else if ( m_OutputStyle == Conservative )
		buffEndObj = "endobj\n";//buffEndObj = Encoding.ASCII.GetBytes( string.Format( "endobj{0}", std::endl ) );//"endobj\r\n" );
	else
		buffEndObj = "endobj " ;//buffEndObj = Encoding.ASCII.GetBytes( string.Format( "endobj{0}", Keys.SPACE ) );//"endobj " );

	for( auto it = docData.m_xref.begin(); it != docData.m_xref.end(); ++it )
	{
		pdfObjId idNew( it->first );
		pdfReference objNew( doc, &idNew, nullptr, stm.tellp() );
		if ( !it->first.IsFree() && !it->second.IsNull() )
		{

			pdfAtom atm = it->second;

			//buff = atm.m_ID.ID.ToString() + Keys.SPACE + atm.m_ID.GenNum.ToString() + " obj ";
			//bytes = Encoding.ASCII.GetBytes( buff );
			//stm.Write(bytes, 0, bytes.Length);
			stm << atm.GetId() << " obj ";

			atm = atm.Dereference();

			if ( idEncrypt.IsValid() && atm.GetId() == idEncrypt )
				m_bSuspendEncryption = true;

			WriteAtom( doc, stm, atm, 0 );//pair.Value.val);
		
			m_bSuspendEncryption = false;

			// endobj
			//stm.Write(buffEndObj, 0, buffEndObj.Length);
			stm << buffEndObj;
		}

		if (it->first.GetId() != lNextID )//|| lstSection == nullptr)
		{
			if ( iFirstFree == 0 )
				iFirstFree = lNextID;
			while ( lNextID < it->first.GetId() )
			{
				pdfObjId o( ++lNextID, 0, true );
				pdfReference ref( doc, &o, nullptr, 0 );
				lstSection.push_back( ref );
				iSections++;
			}
					/*lstSection = new List<pdfReference>();
					lstNewTable.Add(lstSection);
					lNextID = pair.Key.ID;*/

		}
		lNextID++;
		iSections++;
		lstSection.push_back(objNew);
	}
	lstNewTable.push_back( lstSection );

	
	//
	//lstNewTable.Sort();
	long iXref = stm.tellp();//, idx=0;
 
	if ( m_OutputStyle != Stingy )
		stm << "xref" << std::endl;
	else
		stm << std::endl << "xref" << std::endl;

	char szBuff[25] = "";

	//StringBuilder sTable = new StringBuilder( 30 + 8 + (iSections+lstNewTable.Count+2)*22 );
	//sTable.AppendFormat( "0 {2}\r\n{0:D10} {1:D5} f\r\n", iFirstFree, 65535,  );
	sprintf( szBuff, "%010d", iFirstFree);
	stm << "0 " << iSections << std::endl << szBuff << " 65535 f" << std::endl; 
	std::for_each(lstNewTable.begin(), lstNewTable.end(), [&] (std::list<pdfReference>& lst) 
		{
			if ( lst.size() > 0 )
			{
				//sTable.AppendFormat( "{0} {1}\r\n", lst[ 0 ].m_ID.ID.ToString(), lst.Count );

				//for( int iRef = 0; iRef < lst.size(); iRef++ )// ( pdfReference obj in lst )
				for( auto it = lst.begin(); it != lst.end() ;++it )
				{
					pdfReference& obj = *it;
					//pdfReference obj = lst[iRef];
					//if ( iRef == lst.Count-1 )
						//sTable.AppendFormat( "{0:D10} {1:D5} {2}\r\n", obj.ID.m_bFree ? obj.ID.ID : obj.m_FilePos, obj.m_ID.GenNum, obj.ID.m_bFree ? "f" : "n" );
						sprintf( szBuff, "%010d", obj.GetId().IsFree() ? obj.GetId().GetId() : (int)obj.GetFilePos() );
						stm << szBuff << ' '; 
						sprintf( szBuff, "%05d", obj.GetId().GetGenNum() );
						stm << szBuff << (obj.GetId().IsFree() ? " f" : " n") << std::endl; 
					//else
					//	sTable.AppendFormat( "{0:D10} {1:D5} {2}  ", obj.ID.m_bFree ? obj.ID.ID : obj.m_FilePos, obj.m_ID.GenNum, obj.ID.m_bFree ? "f" : "n" );
				};
				lst.clear();
			}
		});
	//foreach (List<pdfReference> lst in lstNewTable)
	//{
	//    if( lst.Count>0 )
	//    {
	//        sTable.AppendFormat("{0} {1}\r\n", lst[0].m_ID.ID.ToString(), lst.Count);

	//        foreach (pdfReference obj in lst)
	//        {
	//            sTable.AppendFormat( "{0:D10} {1:D5} {2}\r\n", obj.ID.m_bFree ? obj.ID.ID : obj.m_FilePos, obj.m_ID.GenNum, obj.ID.m_bFree ? "f" : "n" );
	//        }
	//        lst.Clear();
	//    }
	//}
	lstNewTable.clear();


	dictTrailer.SetNumber( "Size", iSections );

	// trailer 
	stm << "trailer";

	//// should we write the new Encrypt?
	//pdfDictionary dicSavEnc = docData.m_bEncrypted ? dictTrailer[ "Encrypt" ] as pdfDictionary : nullptr;
	//if ( docData.m_NewSecurity != nullptr )
	//    dictTrailer[ "Encrypt" ] = docData.m_NewSecurity.EncryptionDictionary;

	// Did they change the Doc IDs?  Std does
	pdfArray arrSaveIDs;
	if( docData.m_bEncrypted )
		arrSaveIDs = dictTrailer["ID"];

	vector<byte> bNewID1 , bNewID2 ;
	if ( docData.m_pNewSecurity != nullptr )
	{
		if ( !dNewEnc.IsNull() )
		{
			docData.m_pNewSecurity->GetNewID1( bNewID1 );
			docData.m_pNewSecurity->GetNewID2( bNewID2 );
			if ( bNewID1.size()>0 && bNewID2.size()>0 )
			{
				pdfArray arrIDs( const_cast<pdfDocument&>(doc), 2 );
				arrIDs.Add( pdfString( const_cast<pdfDocument&>(doc), (const byte*)&bNewID1[0], bNewID1.size(), StringEncoding::Byte ) );
				arrIDs.Add( pdfString( const_cast<pdfDocument&>(doc), (const byte*)&bNewID2[0], bNewID2.size(), StringEncoding::Byte ) );
				dictTrailer.Set( "ID", arrIDs );
			}
		}
		else
		{
			dictTrailer.Remove( "Encrypt" );
		}
	}
	//Make sure we don't encrypt this!
	m_bSuspendEncryption = true;

	WriteDict( doc, stm, dictTrailer, 0 );

	// restore IDs
	if ( !arrSaveIDs.IsNull() &&  bNewID1.size()>0 && bNewID2.size()>0 )
	{
		dictTrailer.Set( "ID", arrSaveIDs );
	}

	// restore encryption settings
	if ( dicSavEnc.IsNull() )
		dictTrailer.Remove( "Encrypt" );
	else
		dictTrailer.Set( "Encrypt", dicSavEnc );

	m_bSuspendEncryption = false;


	// startxref block
	stm << std::endl << "startxref" << std::endl << iXref << std::endl << "%%EOF" << std::endl;
//			stm.Write(Encoding.ASCII.GetBytes(buff), 0, buff.Length);
}

void pdfWriter::WriteAtom( const pdfDocument& doc, std::ostream& stm, pdfAtom& atm, int iIndent )
{
	string buff;
	//string sCRLF = "Yadda\r\n";
	switch (atm.GetType())
	{
		case AtomType::Stream:
		{
			pdfBlob x(atm);
			WriteStream(doc, stm, x, iIndent);
			break;
		}
		case AtomType::Dictionary:
		{
			pdfDictionary d(atm);
			WriteDict(doc, stm, d, iIndent);
			break;
		}
		case AtomType::Array:
		{
			pdfArray arr(atm);
			WriteArray(doc, stm, arr, iIndent);
			break;
		}
		case AtomType::Reference:
			stm << atm.GetId() << " R";
			break;
		case AtomType::String:
		{
			pdfString s(atm);
			WriteString( stm, s );
			break;
		}
		case AtomType::Name:
		{
			pdfName n(atm);
			WriteName( stm, n );
			break;
		}
		case AtomType::Null:
			stm << "null";
			break;
		case AtomType::Boolean:
			stm << std::boolalpha << atm.Bool();
			break;
		case AtomType::Real:
		{
			pdfReal r(atm);
			WriteReal( stm, r );
			break;
		}
		case AtomType::Integer:
			stm << atm.Int();
			break;
		case AtomType::Integer64:
			stm << atm.Int64();
			break;
		case AtomType::Keyword:
			stm << atm.Str();
			break;
		default:
			stm << atm;
			/*buff = atm.Obj.ToString();
			bData = Encoding.ASCII.GetBytes( buff );
			stm.Write(bData, 0, bData.Length);*/
			break;
	}
}

void pdfWriter::WriteNameChar( std::ostream& stm, char c )
{
	if (!IsDelimiter(c) && c != '#' && c >= 33 && c <= 126)
	{
		stm << c;
	}
	else
	{
		stm << '#' << std::hex << (byte)c << std::dec;
	}
}

void pdfWriter::WriteChar( std::ostream& stm, byte c )
{
	if (c == '\r')
	{
		stm << "\\r";
	}
	else if (c == '\n')
	{
		stm << "\\n";
	}
	else if (c == '\t')
	{
		stm << "\\t";
	}
	else if (c == '(' || c == ')' || c == '\\')
	{
		stm << '\\' << c;
	}
	else
	{
		//byte[] dat = Encoding.UTF8.GetBytes(c.ToString());
		//stm.Write(dat, 0, dat.Length);
		stm << c;
	}
}

void pdfWriter::WriteString( std::ostream& stm, pdfString& d )
{
	//static byte bCRLF[ 2 ] = { 13, 10 };
	static const byte bLEMarker[ 2 ] = { 254, 255 };
	static const byte bBEMarker[ 2 ] = { 255, 254 };

	StringEncoding strType = d.GetStringEncoding();
	if ( !m_bSuspendEncryption && m_secEncryptor != nullptr && !d.GetEncrypted() )
		strType = StringEncoding::ByteAsChars;

	if ( strType == StringEncoding::Byte )
	{
		WriteHexString( stm, d);
		return;
	}

	if ( m_OutputStyle == NicelyFormatted && d.IsIndirect() )
		stm << std::endl;//.Write( Utils.bCRLF, 0, Utils.bCRLF.Length );
		
	// From here on USE ONLY m_HexBytes - DON'T CALL THE PROPERTY!!!!
	stm << '(';

	// TODO !!!!!
	CSharedBuff buff( d.GetStringBytes(false) );
	if ( buff.GetLength() > 0 )
	{
		try
		{
			CSharedBuff buffNew;
			ostream& stmNew( buffNew );

			// If unencrypted then we need to encrypt a temp array and save it
			if ( !m_bSuspendEncryption && m_secEncryptor != nullptr && !d.GetEncrypted() )
			{
				// if Unicode then make sure we insert the header bytes
				if ( d.GetStringEncoding() == StringEncoding::UTF16LE )
				{
					// Write out in little-endian.
					stmNew.write( (const char*)bLEMarker, 2 );
				}
				else if ( d.GetStringEncoding() == StringEncoding::UTF16BE )
				{
					stmNew.write( (const char*)bBEMarker, 2 );
				}

				stmNew.write( (const char*)buff.get(), buff.GetLength());

				m_secEncryptor->EncryptObject( d, buffNew );

				// reset this, try to stay decrypted
				d.SetEncrypted( false );
			}
			else 
			{
				if ( !d.GetEncrypted() )//don;t write these out if encrypted
				{
					if ( d.GetStringEncoding() == StringEncoding::UTF16LE )
					{
						// write out in little-endian.
						stm.write( (const char*)bLEMarker, 2 );
					}
					else if ( d.GetStringEncoding() == StringEncoding::UTF16BE )
					{
						// write out in big-endian.
						stm.write( (const char*)bBEMarker, 2 );
					}
				}

				buffNew = buff;//
			}
			// buffNew buffNewbuffNewbuffNewbuffNew
			int iCols = 0;
			const char* pStr = (const char*)buffNew.get();
			size_t len = buffNew.GetLength();
			for (size_t i = 0; i < len; i++)
			{
				if ( m_iMaxCharsPerLine > 0 && iCols == m_iMaxCharsPerLine )
				{
					iCols = 0;
					stm << '\\' << std::endl;
				}
				iCols++;

				WriteChar(stm, pStr[i]);
			}
		}
		catch ( const std::exception& e )
		{
			//Debug.Print("EXCEPTION: " + e.Message);
		}
	}

	stm << ')';
}

void pdfWriter::WriteName( std::ostream& stm, pdfName& d )
{
	string sVal = d.Str();

	stm << '/';

	if (sVal.length() == 0)
		stm << 'X';
	else
		std::for_each( 	sVal.begin(), sVal.end(), [&] (const char c){
				WriteNameChar( stm, c); 
			});

	//stm.WriteByte((byte)' ');
}

void pdfWriter::WriteHexString( std::ostream& stm, pdfString& d )
{
	stm << '<' << std::hex;

	CSharedBuff buff( d.GetStringBytes(false) );
	if ( buff.GetLength() > 0 )
	{
		istream& stmBytes( buff );
		size_t i = 0;//stmBytes.tellg();
		for( i = 0; i < buff.GetLength();i++ )
			stm << stmBytes.get();


		//stm.write( (const char*)buff.get(), buff.GetLength() );
		/*StringBuilder sb = new StringBuilder( d.m_HexBytes.Length * 2 );
		foreach ( byte c in d.m_HexBytes )
			sb.AppendFormat( "{0:X2}", c );
		byte[] dat = Encoding.ASCII.GetBytes( sb.ToString() );
		stm.Write( dat, 0, dat.Length );*/
	}

	stm << std::dec << '>';
}

void pdfWriter::WriteDict( const pdfDocument& doc, std::ostream& stm, pdfDictionary& d, int iIndent )
{
	//string sbIndent = sKey;// new StringBuilder(iIndent + 1);
	//sbIndent.Insert(0, "\t", iIndent);
	int iItemsWritten = 0, iLines = 0;
	string sbIndent = "";
	string buff = "";
	//byte[] arrBytes = nullptr;
	//byte[] arrTabs = nullptr;

	if ( m_OutputStyle == NicelyFormatted )
	{
		sbIndent = string( iIndent, '\t' );
//		sbIndent = string( iIndent * m_iIndent, ' ' );
		stm << std::endl << sbIndent;
	}
	else if ( m_OutputStyle == Neat )
	{
		stm << std::endl;
	}
	else if ( m_OutputStyle == Conservative )
	{
		stm << ' ';
	}

	stm << "<<";

	if ( m_OutputStyle == NicelyFormatted )
	{
		sbIndent = string( ( iIndent + 1 ), '\t' );
		//sbIndent = string( ( iIndent + 1 ) * m_iIndent, ' ' );
		//arrTabs = Encoding.ASCII.GetBytes( sbIndent );
	}

	d.ForEach( [&] ( const char* szKey, pdfAtom& a )
			{
				// ForEach always derefs, but now we want that ref to write, and not the whole obj
				pdfAtom atm( a.GetRef().IsNull() ? a : a.GetRef() );
				//pdfAtom atm( a );
				//if( !atm.GetRef().IsNull() )
				//	atm = atm.GetRef();

				//if (iItemsWritten>0 && iItemsWritten % 2 == 0)
				//{
				if ( m_OutputStyle == NicelyFormatted )
				{
					iLines++;
					stm << std::endl << sbIndent;
				}
				else if ( m_OutputStyle == Neat )
				{
					iLines++;
					stm << std::endl;
				}
				else if ( m_OutputStyle == Conservative)
					stm << ' ';

				//}
				//else
				//	stm.WriteByte(' ');
				iItemsWritten++;

				// Key Name
				//if( a.Value!=nullptr && a.Key!=nullptr )
				//if( !a.IsNull() )
				//{
					//pdfAtom atmName = pdfName( doc, szKey );//doc.Factory.CreateName(a.Key, false);
					//WriteAtom( doc, stm, atmName, iIndent + 1);
					pdfName n( doc, szKey );
					WriteName( stm, n );

					// for soem types we need a space just as because there may be no other delimiter.
					if ( m_OutputStyle == Neat || m_OutputStyle == NicelyFormatted ||
							atm.IsNumber() || 
							//atm.GetType() == AtomType::Name ||
							atm.GetType() == AtomType::Reference ||
							atm.GetType() == AtomType::Null)
						stm << ' ';

					// Value
					WriteAtom(doc, stm, atm, iIndent + 1);
				//}

			} );
	//if (iItemsWritten>0)
	//{
		//stm.WriteByte(13);
		//stm.WriteByte(10);
	//}

	if ( m_OutputStyle == NicelyFormatted )
	{
		//stm << std::endl << string( iIndent * m_iIndent, ' ' ) << ">>" ;
		stm << std::endl << string( iIndent, '\t' );
	}
	else if ( m_OutputStyle == Neat )
	{
		stm << std::endl ;
	}
	else if ( m_OutputStyle == Conservative )
	{
		stm << ' ' ;
	}
	stm << ">>" ;
}

void pdfWriter::WriteStream( const pdfDocument& doc, std::ostream& stm, pdfBlob& d, int iIndent )
{
	WriteDict(doc, stm, d, iIndent);

	stm << " stream\n";

	//
	if (!m_bSuspendEncryption && doc.IsEncrypted() && m_secEncryptor != nullptr && !d.GetEncrypted() )
	{
		CSharedBuff tmp;
		d.GetBytes( tmp, true, false );

		m_secEncryptor->EncryptObject( d, tmp );
		// TODO make sure the length getting written is right
		stm.write( (const char*)tmp.get(), ((ostream&)tmp).tellp() );
		//stm.write( (const char*)tmp.get(), tmp.GetLength() );

		d.SetEncrypted( false );
	}
	else
		d.GetBytes( stm, true, false );

	//if ( arrBytes != nullptr )
	//	stm.Write( arrBytes, 0, arrBytes.Length );

	if ( m_OutputStyle == Stingy  )
		stm << "\nendstream\n";
	else
		stm << "\nendstream";

}

void pdfWriter::WriteArray( const pdfDocument& doc, std::ostream& stm, pdfArray& d, int iIndent )
{
	string buff = "[";// std::endl + sbIndent + "[";


	//int iLines = 0;
	int iItemsWritten = 0, iCol = 0, iCols = ( m_OutputStyle == NicelyFormatted ? 8 : 32 );
	if ( m_OutputStyle == NicelyFormatted )
	{
		//sbIndent = new string( iIndent * m_iIndent, ' ' );
		//buff = std::endl + sbIndent;

	}
	else if ( m_OutputStyle == Conservative )
		iCols = 64;
	else if ( m_OutputStyle == Stingy )
		iCols = 128;

//			iCols = 2;

	if ( d.GetData()->m_vecArray.size() > iCols )
	{
		stm << std::endl;

		if ( m_OutputStyle == NicelyFormatted )
			WriteIndent( stm, iIndent );

		stm << '[' << std::endl;

		if ( m_OutputStyle == NicelyFormatted )
			WriteIndent( stm, ++iIndent );
	}
	else
	{
		stm << '[';
		if(  m_OutputStyle != Stingy )
			stm << ' ';
	}

	//stm.Write(Encoding.ASCII.GetBytes(buff), 0, buff.Length);
	//for(int i =0; i < d.m_lst.Count; i++ )// ( pdfAtom atm in d.m_lst )
	d.ForEach( [&] (pdfAtom& a) {
			// ForEach always derefs, but now we want that ref to write, and not the whole obj
			pdfAtom atm( a.GetRef().IsNull() ? a : a.GetRef() );
			//AtomType typ = atm.Type;
			//pdfObjId ID = atm.m_ID;

			if ( iCol >= iCols )// && iItemsWritten % iCols == 0 )
			{
				iCol = 0;
	//			iLines++;
				stm << std::endl;
				if ( m_OutputStyle == NicelyFormatted )
					WriteIndent( stm, iIndent );
			}
			else if( iCol > 0 )
				stm << ' ';
			iCol++;
			iItemsWritten++;

			// 
			//if ( atm.Value.IsNumber || atm.Value.Type == AtomType::Name || atm.Value.Type == AtomType::Reference || atm.Value.Type == AtomType::Null )
			//	stm.WriteByte( ' ' );

			WriteAtom(doc,stm, atm, iIndent + 1);
		});

	if ( d.GetData()->m_vecArray.size() > iCols )
	{
		--iIndent;
		stm << std::endl;
		WriteIndent( stm, iIndent );
	}
	else if( m_OutputStyle != Stingy )
		stm << ' ';
	
	stm << (byte)']';
}

void pdfWriter::WriteReal( std::ostream& stm, pdfReal& real )
{
	double d = real.Real();
	if( d == 0 )
	{
		stm << '0';
		return;
	}
	int iPrec = Math::Max( 1, Math::Min( real.GetPrecision(), 6 ) );

	sprintf( m_szBuff, "%.*f", iPrec, d );

	int i = strlen(m_szBuff)-1;
	while( i>0 && m_szBuff[i] == '0' )
	{
		m_szBuff[i] = '\0';
		i--;
	}
	//i = strlen(m_szBuff);
	if( i > 0 && m_szBuff[i] == '.' )
		m_szBuff[i] = '\0';

	/*memset( m_szBuff, 0, sizeof(m_szBuff)/sizeof(m_szBuff[0]) );

	int i = 0, len = 0;
	int decimal, sign;
	char* sz = _fcvt( real.Real(), iPrec, &decimal, &sign ); 

	if( sign )
		m_szBuff[len++] = '-';
	if( real.Real() < 0 )
		stm << '0';
	while( i < strlen(sz) )
	{
		if( i == decimal )
			m_szBuff[len++] = '.';
		m_szBuff[len++] = sz[i++];
	}

	i = len-1;
	while( i>0 && ( m_szBuff[i] == '0' || m_szBuff[i] == '.' ))
	{
		m_szBuff[i] = '\0';
		if( m_szBuff[i] == '.' )
			break;
		i--;
	}*/

	stm << m_szBuff;
}

void pdfWriter::WriteIndent( std::ostream& stm, int iIndent )
{
	if ( iIndent > 0 )
	{
		string s = m_mapIndents[iIndent];
		if( s.length() == 0 )
		{
			s = m_mapIndents[iIndent] = string( iIndent, '\t' );
		}
		stm << s;

//		stm << string( iIndent * m_iIndent, ' ' );
		//if ( m_Indent.Length < iIndent )
		//{
		//	m_Indent = new byte[ iIndent ];
			//for ( int i = 0; i < iIndent; i++ )
				//m_Indent[ i ] = ' ';
		//}
		//stm.Write( m_Indent, 0, iIndent );
	}
}

void pdfWriter::Decrypt(const pdfDocument& doc)
{
//	m_iIndent = m_iMaxCharsPerLine = 0;
//	m_OutputStyle = Default;
	CDocData& docData( *(const_cast<CDocData*>(doc.GetData())) );

	pdfSecurityHandler* secDecryptor = docData.m_bEncrypted ? docData.m_pSecurity : nullptr;//not actually going to do any decrypts, directly, at least
	m_secEncryptor = docData.m_pNewSecurity != nullptr ? docData.m_pNewSecurity : secDecryptor;

	if ( secDecryptor != nullptr || m_secEncryptor != nullptr )
	{
		if ( secDecryptor != m_secEncryptor && secDecryptor != nullptr )
		{
			try
			{
				for( auto it = docData.m_xref.begin(); it != docData.m_xref.end(); ++it )
				{
					if ( !it->first.IsFree() && !it->second.IsNull() )
					{
						pdfAtom atm( it->second.Dereference() );

						DecryptAtom( atm );
					}
				}
				secDecryptor = nullptr;
			}
			catch ( const std::exception& e )
			{
				std::clog << e.what();
				//Debug.Print( e.Message );
			}
		}

		// user may be trying to remove security from doc - if they've gotten this far then we must have checked the permissions
		if ( m_secEncryptor->EncryptionDictionary().IsNull() )
			m_secEncryptor = nullptr;
	}
}

void pdfWriter::DecryptAtom( pdfAtom& atm )
{
	switch ( atm.GetType() )
	{
		case AtomType::String:
			{
				pdfString str( atm );
				str.GetStringBytes(true);// TODO make a func like this for Blob - one that returns a shared buff - either way make them consistent with each other.
			}
			break;
		case AtomType::Array:
			{
				pdfArray arr( atm );
				arr.ForEach( [&] ( pdfAtom& a ) {
						if( !a.IsNull() && !a.IsIndirect() )
							DecryptAtom( a ); });
			}
			break;

		case AtomType::Stream:
			{
				pdfBlob str = pdfBlob( atm );
				str.EnsureLoaded( true );//loads & decrypts

				// fall through; the next part gets all the dictionary entries.
			}

		case AtomType::Dictionary:
			{
				pdfDictionary dict(atm);
				dict.ForEach( [&] ( const char* szKey, pdfAtom& a ) {
						if( !a.IsNull() && !a.IsIndirect() )
							DecryptAtom( a ); });
			}
			break;
	}
}

bool pdfWriter::IsDelimiter(char c) const throw()
{
	switch (c)
	{
		case '(':
		case ')':
		case '/':
		case ' ':
		case '>':
		case '<':
		case '[':
		case ']':
			return true;
	}
	return false;
}

};
